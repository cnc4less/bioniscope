\chapter{System Development}
\section{Subsystems}
\label{sec:subsystems}

The system will be split up into a number of subsystems, shown
in~\cref{fig:subsystems}. Each of these subsystems is described in more detail
in the sections below, and a brief description is given immediately below.

\begin{itemize}

  \item Two analogue input channels come into the system, and are amplified and
  offset by amplification circuitry (with the gain controlled by a central
  microcontroller).

  \item These channels are both sampled using an Analogue to Digital Converter,
  which feeds into the microcontroller.

  \item A number of digital inputs are also fed straight into the
  microcontroller

  \item Through a Bluetooth transceiver, an Android device interacts with the
  microcontroller, receiving samples of both the analogue and digital inputs and
  controlling things such as the sampling rate and amplifier gain.

\end{itemize}

\begin{landscape}
  \begin{figure}
    \scalebox{0.8}{
      \begin{tikzpicture}
        \node [io] (input1) {Input 1};
        \node [io, below of=input1, node distance=3cm] (input2) {Input 2};

        \node [process, right of=input1] (amp1) {Amplifier};
        \node [process, right of=input2] (amp2) {Amplifier};
        \path [arrow] (input1) -- (amp1);
        \path [arrow] (input2) -- (amp2);
        \coordinate [below of=amp1, node distance=1.5cm] (centreamp);

        \node [process, right of=centreamp] (adc) {ADC};
        \path [arrow] (amp1) -| (adc);
        \path [arrow] (amp2) -| (adc);

        \node [process, right of=adc] (microcontroller) {Microcontroller};
        \path [barrow] (adc) -- (microcontroller);

        \node [process, below=2.5cm of microcontroller.320] (inputdigital) {Digital Inputs};
        \path [arrow] (inputdigital) -- (microcontroller.320);

        \node [process, right of=microcontroller] (wifi) {Bluetooth Transceiver};
        \node [io, right of=wifi, node distance=5.5cm, text width=4.5em] (frontend) {User Interface};
        \path [barrow] (microcontroller) -- (wifi);
        \path [bdarrow] (wifi) -- (frontend);

        \coordinate[above of=amp1, node distance=2cm] (aboveamp1);
        \coordinate[below of=amp2, node distance=1.5cm] (belowamp2);
        \path [arrow] (microcontroller) |- (aboveamp1) -- (amp1);
        \path [arrow] (microcontroller.220) |- (belowamp2) -- (amp2);
      \end{tikzpicture}
    }
    \caption[Oscilloscope Subsystems]{Subsystems within the oscilloscope}
    \label{fig:subsystems}
  \end{figure}
\end{landscape}

\subsection{Analogue Inputs}

For the purposes of this project wires are sufficient, however in a real-life
scenario high-impedance, low-inductance test probes (usually coaxial cable)
should be used.

\subsection{Power Supply}

\subsubsection*{Requirements}

While it is not explicitly shown in~\cref{fig:subsystems}, the amplifiers, ADC,
microcontroller and Bluetooth transceiver will all need to be powered.

A \SI{5}{\V} rail will be needed that can source the following
current\footnote{The figures are overestimations meaning there will
definitely be enough current available.}:
\begin{itemize}
  \item \SI{5}{\mA} for the two amplifiers combined
  \item \SI{5}{\mA} for the two digital potentiometers combined
  \item \SI{15}{\mA} for the ADC
  \item \SI{25}{\mA} for the microcontroller
  \item \SI{30}{\mA} for the LED
  \item \SI{30}{\mA} for the Bluetooth module
\end{itemize}
which gives a total of \SI{110}{\mA}.

Similarly, a \SI{-5}{\V} rail will be needed for the first-stage amplifier that
can sink at least \SI{5}{\mA}, and a ground rail will be needed that can source
at least \SI{110}{\mA}\footnote{There will always be a positive load, so we do
  not need to worry about the ground rail being able to source the \SI{5}{\mA}
that will flow to the \SI{-5}{\V} rail}.

\subsubsection*{Circuit}

While researching this part of the circuit, your author came upon a chip known
as an \textit{inverting charge pump}, a device that takes $V_s$ and \SI{0}{\V}
as inputs and outputs $-V_s$ and \SI{0}{\V} as outputs\footnote{The way it does
  this is very clear, but revolves around charging up a capacitor in one
direction and then discharging it in the opposite direction.} --- essentially
providing a low-current\footnote{The highest commonly-available current rating
  seems to be about \SI{1}{\A}} dual power supply. This was implemented into the
  oscilloscope's power supply as it means only a positive voltage and ground
  need to be input, meaning it could potentially be powered by battery.

Many of the chips (primarily the ADC and microcontroller) require very precise
and stable power rails, and to that effect a voltage regulator will be used.
Commonly known as a 7805 (although that specific device will not be used in this
case), a voltage regulator takes a relatively high voltage (e.g., \SI{9}{\V}) as
input and outputs a very precise lower voltage (e.g., \SI{5}{\V}) that does not
fluctuate even when the output current changes rapidly. In addition to this,
decoupling capacitors will be added to the amplifier, ADC and microcontroller to
further reduce voltage fluctuations (the capacitor values will be taken directly
from the relevant datasheets).

\begin{landscape}
  \begin{figure}[h]
    \includegraphics[width=\linewidth]{img/power_supply/circuit.png}
    \caption{Power supply circuit diagram}
    \label{fig:powerSupplyDiagram}
  \end{figure}
\end{landscape}

These two ideas, then, give rise to the circuit diagram shown
in~\cref{fig:powerSupplyDiagram}. A single-rail power supply (perhaps from a
\SI{9}{\V} battery) is used to power the system, and a switch (to let the user
switch the oscilloscope off and on) and a forward-biased diode (to limit damage
if the power supply is connected backwards) are connected immediately to the
power rail.

A MAX883 chip is then used as a fixed \SI{5}{\V} voltage regulator. Most
semiconductor companies produce PDIP package \SI{5}{\V} voltage regulators, but
Maxim Integrated's chip was chosen due the availability of free samples. As
specified in the datasheet, a \SI{100}{\nF} capacitor is placed on the input and
a \SI{2.2}{\uF} capacitor on the output.

A MAX660 is then used as an inverting charge pump (this specific chip was chosen
for similar reasons to the MAX883). Again, as specified on the datasheet a
\SI{22}{\uF} capacitor is placed on the output and another between $CAP-$ and
$CAP+$.

\subsection{Amplifiers}

Each amplifier will have two purposes:
\begin{itemize}
  \item To amplify the signal based on the Voltage Control of the oscilloscope.
    This is needed so the user can input a range of different voltage signals.

  \item To shift the signal so the minimum voltage is \SI{0}{\volt}, rather
    than some negative voltage. This is required because the ADC will only
    accept an input greater than \SI{0}{\volt}.
\end{itemize}

The chosen ADCs require an input voltage between \SI{0}{\volt} and
\SI{5}{\volt}\footnote{The maximum voltage is actually $V_{REF+}$, which will be
connected to $V_{CC}$ for simplicity, which in this case is \SI{5}{\volt}}. A
non-inverting summing amplifier would not be suitable beause the offset added to
the signal needs to remain constant while the gain changes, so instead the
amplifier will be split into two stages.

The first stage will amplify the signal and offset it to be between
\SI{0}{\volt} and \SI{-5}{\volt}, below which the op-amp will saturate.

The second stage will invert this signal with a voltage gain of $-1$, meaning
the output voltage will be between \SI{0}{\volt} and \SI{5}{\volt} as required.

\subsubsection{First Stage}

\paragraph{Circuit}
This stage will be implemented using a summing amplifier, with the inputs
consisting of the input signal and a fixed voltage (for the sake of simplicity,
the 5V supply wil be used).

See~\cref{fig:first_stage_amplifier_circuit} for a circuit diagram.

\paragraph{Component Calculations}

Suppose that the input signal varies from $-V_1$ to $+V_1$, and the amplifier
has a gain of $A$ and an offset of $B$. Then the output voltage $V_o$ will be
given by

\begin{equation*}
  -V_o = \frac{R_f}{R_1} V_i + \frac{R_f}{R_2} \cdot \SI{5}{\volt}
\end{equation*}

The first term will range from $-A\cdot V_1$ to $+A\cdot V_1$, and the second
term will be $B$. So $-V_o$ will range from $B-A\cdot V_1$ to $B+A\cdot V_1$.
Choosing a value of $B=\SI{2.5}{\volt}$ means that $-V_o$ will vary equally
above and below \SI{2.5}{\volt}, as we want\footnote{The op amp will saturate
before outputting a voltage above \SI{5}{\volt}, so we don't need to worry about
this. If the gain or input voltage is sufficiently large, $-V_o$ could fall
below \SI{0}{\volt}. This means the next stage must saturate at $\SI{0}{\volt}$
and not output negative voltages, whatever the input.  }(because the voltage
must be between \SI{0}{\volt} and \SI{5}{\volt}, and \SI{2.5}{\volt} is the
midpoint of those two).

$R_f$ and $R_2$ will be fixed to give $\frac{R_f}{R_2}=0.5$ to get the required
offset. $R_1$ will be a digital potentiometer acting as a rheostate (variable
resistor), allowing the microcontroller to control the gain of the amplifier.

The input voltage range is from \SI{\pm 50}{\mV} to \SI{\pm 5}{\V}, so the gain
$A=\frac{R_f}{R_1}$ must vary from 0.5 to at least 50.  Digital potentiometers
are readily available in a number of values, so the standard \SI{10}{\kilo\ohm}
option will be chosen. This means the potentiometer can vary from the minimum
resistance (usually \SI{75}{\ohm}) to \SI{10}{\kilo\ohm}.

Using the values for $A$ and $R_1$, this gives a value of
$R_f=\SI{5}{\kilo\ohm}$, meaning $A$ will range from
$\frac{\SI{5}{\kilo\ohm}}{\SI{10}{\kilo\ohm}}=0.5$ to
$\frac{\SI{5}{\kilo\ohm}}{\SI{75}{\ohm}} \approx 66.7$, as required.  In turn,
this gives a value of $R_2 = \SI{10}{\kilo\ohm}$.

\begin{figure}[ht]
  \begin{circuitikz}[european]
    % Inputs and input resistors
    \node (vin1) {};
    \node (vin2) [below=1 of vin1] {};
    \node (rpoint1) [right=2.5 of vin1] {};
    \node (rpoint2) [right=2.5 of vin2] {};
    \coordinate (middlevin1vin2) at ($(vin1)!0.5!(vin2)$);
    \node (rpoint) at (rpoint1|- middlevin1vin2) {};

    \draw (vin1) to[R, l=$R_2\equal\SI{10}{\kilo\ohm}$] (rpoint1);
    \draw (rpoint2) to[pR, l_=$R_1 \in \lb\SI{75}{\ohm}\comma
    \SI{10}{\kilo\ohm}\rb$, label/align=rotate, -o] (vin2) node [anchor=east]{$V_{in}$};
    \draw (rpoint1) to[short] (rpoint);
    \draw (rpoint2) to[short] (rpoint);
    \node [circ] (crpoint) at (rpoint) {};

    % Op amp and feedback resistor
    \node (rfpoint) [right=1 of rpoint] {};
    \node[op amp](oa) [right=0.5 of rfpoint] {};
    \node (aboverfpoint) [above=1.5 of rfpoint] {};
    \node (2xaboverfpoint) [above=1.5 of aboverfpoint] {};
    \node (aboveoaout) at (oa.out|- aboverfpoint) {};
    \node[ground](gnd) [below=0.5 of rfpoint,anchor=center] {};
    \node (vo) [right=1 of oa.out] {};

    \draw (rpoint) to[short] (rfpoint);
    \draw (rfpoint) to[short] (aboverfpoint);
    \draw (aboverfpoint) to[R=$R_f\equal\SI{5}{\kilo\ohm}$] (aboveoaout);
    \draw (aboveoaout) to[short] (oa.out);
    \node [circ] (crfpoint) at (rfpoint|- oa.-) {};

    \draw (rfpoint) |- (oa.-);
    \draw (gnd) |- (oa.+);
    \draw (oa.out) to[short] (vo) node [anchor=west] {$V_{out}$};

    % 5V rail
    \node (leftofvin1) [left=0.5 of vin1] {};
    \node (5vraill) at (leftofvin1|- 2xaboverfpoint) {};
    \node (5vrailr) [right=3 of 5vraill] {};
    \node (5vrailm) at (vin1|- 5vraill) {};

    \draw (5vraill) to[short] (5vrailr) node [anchor=west] {$\SI{5}{\volt}$};
    \draw (5vrailm) to[short] (vin1);
  \end{circuitikz}
  \caption[1\ts{st} Amplifier Stage]{First stage amplifier circuit diagram}
  \label{fig:first_stage_amplifier_circuit}
\end{figure}

\paragraph{Component Selection}

The Microchip MCP4131-103E/P will be used for the digital potentiometer. It
offers enough precision (typically 0.25\%), offers a simple interface for
changing the resistance (SPI) and is cheap and readily available in a PDIP
package. Additionally, free samples are available from Microchip. To make the
component calculations made earlier work, the \SI{10}{\kilo\ohm} MCP4131-103
variety will be used.

The op-amps should be of rail-to-rail type (i.e. they can saturate at almost 0V
and $V_s$) and be able to cope with $V_s=\SI{5}{\volt}$, $V_i=\SI{5}{\volt}$ and
input frequencies of up to $\SI{1}{\MHz}$. The Analog Devices AD8031 meets all
of these requirements (at $\SI{1}{\MHz}$ it gives an open-loop gain of almost
$\SI{25}{\decibel}$) and is also cheap and readily available in PDIP packaging.
Due to the availability of free samples, 2 AD8032ANZs (consisting of two AD8031
op amps in each chip) will be used.

\subsubsection{Second Stage}
This stage simply has to invert the previous stage, saturating at \SI{0}{\volt}
and \SI{5}{\volt}. For this we can use a simple inverting amplifier.

\begin{equation*}
V_{out}=\frac{R_f}{R_1}V_{in}
\end{equation*}

Choosing a standard value of $R_f=\SI{10}{\kilo\ohm}$, we obtain
$R_1=\SI{10}{\kilo\ohm}$.

As detailed in the previous section, AD8031 op amps will be used.

See~\cref{fig:second_stage_amplifier_circuit} for a circuit diagram.

\begin{figure}[ht]
  \begin{circuitikz}[european]
    \node (vin) {};
    \node (rpoint) [right=2.5 of vin] {};
    \node [op amp] (oa) [right=0.5 of rpoint] {};
    \node (aboverpoint) [above=1.5 of rpoint] {};
    \node (aboveoaout) at (oa.out |- aboverpoint) {};
    \node [ground] (gnd) [below=0.5 of rpoint, anchor=center] {};
    \node (vo) [right=1 of oa.out] {};


    \draw (rpoint) to[R, l_=$R_1\equal\SI{10}{\kilo\ohm}$] (vin) node
      [anchor=east] {$V_{in}$};
    \node [circ] (crpoint) at (rpoint|- oa.-) {};
    \draw (rpoint) to[short] (aboverpoint);
    \draw (aboverpoint) to [R=$R_f\equal\SI{10}{\kilo\ohm}$] (aboveoaout);
    \draw (aboveoaout) to[short] (oa.out);
    \draw (rpoint) |- (oa.-);
    \draw (gnd) |- (oa.+);
    \draw (oa.out) to[short] (vo) node [anchor=west] {$V_{out}$};
  \end{circuitikz}
  \caption[2\ts{nd} Amplifier Stage]{Second stage amplifier circuit diagram}
  \label{fig:second_stage_amplifier_circuit}
\end{figure}

\subsubsection{Simulation}
To check the frequency response of the amplification circuit, it was simulated
using LTSpice (see~\cref{fig:amp_sim:circuit}).

To test the simulation, a low frequency sine wave was applied, and as expected
the output was a sine wave of amplitude \SI{2.5}{\volt} between \SI{0}{\volt}
and \SI{2.5}{\volt}. The resultant waveform can be seen
in~\cref{fig:amp_sim:waveform}. A FFT was then applied to this waveform to
obtain the frequency spectrums seen in~\cref{fig:amp_sim:fft}. As required, the
spectrum of the output was identical to the spectrum of the input, with the
slightly lower amplitudes being due to a lower wave amplitude (\SI{2.5}{\volt}
c.f. \SI{5}{\volt}).

A frequency sweep was then applied to produce a Bode plot. The details of such a
plot are beyond the scope of this project, but let us just note that the gain is
very consistent across all frequencies we'll be using (as predicted: the op amp
has a stated bandwidth of \SI{80}{\MHz}, much higher than \SI{1}{\MHz}), and
while it becomes almost \SI{9}{\degree} out of phase at very high frequencies,
this is not an issue for this project\footnote{The phase is only important to
the oscilloscope when comparing the phase of two signals. To see two signals on
screen at the same time base, their frequencies must be close enough together
that they're both out of phase by approximately the same amount. Hence their
phase difference is unchanged}.

\begin{figure}[ht]
  \includegraphics[width=\textwidth]{img/amplifier/circuit.png}
  \caption[Amplification Circuit Simulation]{Amplification circuit in LTSpice}
  \label{fig:amp_sim:circuit}
\end{figure}

\begin{landscape}
  \begin{figure}[ht]
    \includegraphics[width=\linewidth]{img/amplifier/waveform_inverted.png}
    \caption[Amplification Circuit Waveform]{Waveform produced by amplification circuit at 1Hz (blue = original,
      red = first stage output, magenta = second stage output)}
    \label{fig:amp_sim:waveform}
  \end{figure}
\end{landscape}

\begin{landscape}
  \begin{figure}[ht]
    \includegraphics[width=\linewidth]{img/amplifier/fft_inverted.png}
    \caption[Amplification Circuit Frequency Spectrum]{FFT of waveform produced by amplification circuit at 1Hz (red =
      original, blue = first stage output, magenta = second stage output)}
    \label{fig:amp_sim:fft}
  \end{figure}
\end{landscape}

\begin{landscape}
  \begin{figure}[ht]
    \includegraphics[width=\linewidth]{img/amplifier/frequency_response_inverted.png}
    \caption[Amplification Circuit Bode Plot]{Frequency response of amplification circuit}
    \label{fig:amp_sim:freq_response}
  \end{figure}
\end{landscape}

\subsubsection{Overall Circuit}

See~\cref{fig:ampCircuitDiagram} for an overall circuit diagram.

\begin{figure}[h]
  \includegraphics[width=\textwidth]{img/amplifier/overall.png}
  \caption[Amplifier circuit diagram]{Circuit diagram of complete amplifier}
  \label{fig:ampCircuitDiagram}
\end{figure}


\subsection{ADCs}
\label{sec:adcs}

As discussed before, these should be able to sample at up to $\SI{1}{\MHz}$. The
only readily available ADCs that can do this in PDIP packaging and have free
samples are the 8-bit half-flash\footnote{Similar to flash ADCs, but requiring
$\approx2^{\frac{n}{2}}$ as opposed to $\approx 2^n$ parts} Maxim Integrated
MAX114 ADCs.

There are a number of modes the ADCs can be operated in, however the pipelined
mode offers a very good compromise between complexity and speed. The full
details are in \textcite{MAX114}, but as the ADCs are operated from a
microcontroller in which there's a delay of \SI{62.5}{\ns} (assuming a
\SI{16}{\MHz} clock) between each instruction, the operating procedure can be
simplified to the following:

\begin{enumerate}
  \item Use $A_0$ and $A_1$ to choose the input signal (there are only two
    inputs in this project, so $A_0$ and $A_1$ are connected together meaning a
    logic $0$ selects input 0 and a logic $1$ selects input 3)
  \item Pull $\overline{CS}$, $\overline{RD}$ and $\overline{WR}$
  \item Wait approximately \SI{250}{\ns}
  \item Pull $\overline{CS}$, $\overline{RD}$ and $\overline{WR}$ back high
  \item Read in a sample from $D_0$ through $D_7$
\end{enumerate}

Taken directly from the datasheet, \cref{fig:MAX114Power} shows the connections
that must be made to power the MAX114 and provide it with a reference voltage.

Additionally, $\overline{PWRDN}$ must be kept high to keep the ADC powered on,
and $MODE$ must be kept high to keep the ADC in Read-Write mode (of which
pipeline mode is a subset). Both of these should be pulled high through a
resistor (\SI{3.3}{\kilo\ohm} being a common value) to limit current. Based on
this,~\cref{fig:adcCircuitDiagram} shows the circuit schematic for the ADC.

\begin{figure}[h]
  \includegraphics[width=\textwidth]{img/adc/circuit.png}
  \label{fig:adcCircuitDiagram}
  \caption[ADC Circuit Diagram]{Diagram showing how ADC will be connected}
\end{figure}

\begin{figure}
  \centering
  \includegraphics[width=0.4\textwidth]{img/adc/max114power.png}
  \label{fig:MAX114Power}
  \caption[ADC Power Connections]{Power connections for the MAX114~\autocite{MAX114}}
\end{figure}


\subsection{Microcontroller}

Due to this author's significant previous experience with AVR microcontrollers,
one will be used as there are no significant disadvantages over a PIC. In
addition, it is easier to obtain free samples from Atmel (the company that
produce AVR microcontrollers) than it is from Microchip (the company that make
PICs). The main requirements the microcontroller needs to satisfy are:

\begin{itemize}
  \item Ability to use a \SI{16}{\MHz} clock
  \item Inbuilt UART communication (to communicate with the Bluetooth module)
  \item At least 32 IO pins:
    \begin{itemize}
      \item 8 for data connections to the ADC
      \item 5 for control connections to the ADC
      \item 8 for digital data inputs
      \item 4 ($DATA$, $SCK$ and two $CS$) for digital potentiometer
        communication
      \item 2 ($RX$ and $TX$) for Bluetooth module communication
      \item 2 ($RX$ and $TX$) for USB module communication (for debugging
        purposes\footnote{While in theory the Bluetooth module should just be
          plug and play, a spare CP2102 USB to USART module will be used to
          allow the microcontroller to talk to a laptop over USB to help fix any
          problems that occur in the prototyping process}).
      \item 3 for ISP header (the connections used to program the AVR)
    \end{itemize}
  \item At least \SI{1}{\kilo byte} of SRAM (to store the 8192 bits of samples)
  \item Availability in a PDIP package
\end{itemize}

The ATMega1284P was chosen because it's the only 8-bit AVR that meets the above
criteria (any AVRs with more than 32 IO pins are not available in PDIP
packages)!

\subsubsection{Circuit}

\begin{figure}[h]
  \includegraphics[width=\textwidth]{img/microcontroller/circuit.png}
  \caption[Microcontroller Circuit Diagram]{Circuit diagram showing connections to the microcontroller}
  \label{fig:microcontrollerCircuitDiagram}
\end{figure}


For the chip to operate, a \SI{16}{\MHz} crystal oscillator must be connected
between $XTAL1$ and $XTAL$, with a \SI{22}{\pF} capacitor from each pin to
ground.

The following power connections must also be made:
\begin{itemize}
  \item Both $GND$s to ground
  \item $V_{CC}$ and $AV_{CC}$ to \SI{5}{\volt}, with a \SI{100}{\nF} and \SI{1}{\uF}
    capacitor in parallel down to ground (acting as decoupling capacitors)
\end{itemize}

$PD0$ and $PD1$ (in their role as $RXD0$ and $TXD0$ for the chip's inbuilt UART
communication) must be connected to $RX$ and $TX$ respectively on the USB to
UART module\footnote{The module labels $RX$ such that it should be connected to
$RX$ on the microcontroller}.

Similarly, $PD2$ and $PD3$ (in their role as $RXD1$ and $TXD1$ for the inbuilt
UART) must be connected to $TX$ and $RX$ respectively on the Bluetooth
module\footnote{Opposite to the USB module, the Bluetooth module labels $RX$
such that it should be connected to $TX$ on the microcontroller}.

$PB5$, $PB6$ and $PB7$ (in their roles as $MOSI$, $MISO$ and $SCK$ in the chip's
programming connections) should be connected to $MOSI$, $MISO$ and $SCK$
respectively on the ISP (programming) header. The $V_{CC}$ and $GND$ on the
programming header should also be connected to $V_{CC}$ and $GND$ on the chip.

$RESET$ (an active-low input that restarts the microcontroller) should be
connected to $V_{CC}$ through a \SI{4.7}{\kilo\ohm} resistor, with a
\SI{10}{\nF} decoupling capacitor down to ground. It should also be connected to
$RESET$ on the ISP header (when programming the microcontroller, the computer
will need to reset it) and through a switch down to ground (to allow the user to
restart the microcontroller if necessary).

Bus A (i.e., $PA0$ through $PA7$) will be connected directly to the digital
inputs, and bus C (i.e., $PC0$ through $PC7$) will be connected to the data
outputs ($D0$ through $D7$ of the ADC). The ADC control lines will be connected
to the unused pins on bus B: $WR$ to $PB0$, $CS$ to $PB1$, $INT$ to $PB2$,
$ADDR$ to $PB3$ and $RD$ to $PB4$.

Finally, the digital potentiometers will be connected to the unused pins on bus
D: $DATA$ to $PD4$, $SCK$ to $PD5$ and the two $CS$s to $PD6$ and $PD7$.

All of these connections are shown visually
in~\cref{fig:microcontrollerCircuitDiagram}.

\subsubsection{Programming}

To program the chip, an AVR programmer must be used (and connected to the ISP
header as detailed above). These are available very cheaply (such as the USBASP
for \pounds 5 from eBay), but an Arduino (essentially a microcontroller
development board) can also be used, as shown in~\cref{fig:arduino_programmer}.
As this author had a spare Arduino, this option was used.

\begin{figure}
  \centering
  \includegraphics[width=0.5\textwidth]{img/microcontroller/arduino_programmer.png}
  \label{fig:arduino_programmer}
  \caption[Arduino as a Programmer]{Breadboard diagram produced by~\textcite{ArduinoProgrammer} showing
  the programming and power connections between an Arduino and an ATMega328}
\end{figure}


\subsubsection{Serial Interface}

The Android device and the microcontroller will communicate via Bluetooth, which
will emulate a serial link. In essence, a form of communication will be
established where sequences of bytes can be sent by both devices simeltanousely.

The following protocol was designed for serial communication between the Android
device and the microcontroller. After taking a full 1024 samples, the
microcontroller checks the serial buffer for one of the following commands and
acts on it, responding via serial if necessary.

Traditionally, serial is a textual interface, however for efficiency's sake in
this case it was used as a binary interface. Each transmitted character is
stored as an 8-bit character, so the protocol is based on the integer values of
those characters. For example, 65 below corresponds to a capital `A'.

\begin{description}

  \item[\texttt{0x00}] Return all samples for the first analogue channel (1024
  bytes, followed by a newline.\footnote{The character used to indicate a new
  line should start in text on a computer. Here, it's just equivalent to
  \texttt{0x0A}})

  \item[\texttt{0x01}] Return all samples for the second analogue channel (1024
  bytes, followed by a newline)

  \item[\texttt{0x02}] Wait for the next transmitted byte, $X$, and return all
  values for the $X$th digital channel (1024 bits = 128 bytes, followed by a
  newline)

  \item[\texttt{0x03}] Use analogue channel 1 to trigger (returns a newline)

  \item[\texttt{0x04}] Use analogue channel 2 to trigger (returns a newline)

  \item[\texttt{0x05}] Wait for the next transmitted byte, $X$, and use the
  $X$th digital channel to trigger (returns a newline)

  \item[\texttt{0x06}] Wait for the next two transmitted bytes, $X$ and $Y$ and
  use $XY$\footnote{For example, if $X = \texttt{0x50}$ and $Y=\texttt{0x1A}$
  then use \texttt{0x501A} as the delay} as the number of microseconds to pause
  in between samples (returns a newline)

  \item[\texttt{0x07}] Wait for the next transmitted byte, $X$, and use $X$ as
  the analogue trigger threshold (returnsa  newline)

  \item[\texttt{0x08}] Wait for the next transmitted byte, $X$, and use the 7
  least significant bits of $X$ as the digital pot value in an amplifier (if the
  most significant bit of $X$ is high, the second amplifier circuit, otherwise
  the first amplifier circuit) (returns a newline)

  \item[\texttt{0x09}] Enable analogue channels 1 and 2 (this means slower
  sampling) (returns a newline)

  \item[\texttt{0x0A}] Noop (this is the newline character) (returns a newline)

  \item[\texttt{0x0B}] Enable analogue channel 1 only (faster sampling)
  sampling) (returns a newline)

\end{description}

So, for example, to receive samples for the second analogue channel the Android
device would have to send \texttt{0x01}, then store the next 1024 received bytes.

\subsubsection{ADC Communication}
The way in which the microcontroller will communicate with the ADC is described
in~\cref{sec:adcs}. Note that while $INT$ is not required for communication, it
is connected as an input to the microcontroller in case the communication
protocol is changed (i.e., a different mode is used over pipelined) during the
prototyping process.

\subsubsection{Digital Potentiometer Commmunication}

The resistance of the digital potentiometers is set using an SPI interface.
While the details can get more complicated, SPI (Serial Peripheral Interface) is
essentially a very simple interface, consisting of four pins: $SCLK$, $MOSI$,
$MISO$ and $\overline{SS}$.

There are two devices: a master and a slave. $SCLK$ is simply a clock output
from master. On either the rising or falling edge of $SCLK$, a bit of data is
transmitted from master to slave on $MOSI$ and slave to master on $MISO$.
$\overline{SS}$ is simply an active low slave select (i.e. the slave only
communicates when $\overline{SS}$ is low).

There are four different SPI modes, of which the digital potentiometers support
two ($CPOL=0=CPHA$ and $CPOL=1=CPHA$). In both modes, data is captured on the
rising edge and propogated on the falling edge. The difference is simply the
first value of the clock: in the first mode, it's low, and in the second it's
high.

The maximum clock supported by the digital potentiomers is \SI{10}{\MHz}, which
is faster than we can reliably communicate at with a \SI{16}{\MHz}
microcontroller anyway.

To send a 16-bit byte to the digital potentiometer the following must be done:
\begin{enumerate}
  \item Pull $\overline{SS}$ low
  \item Wait one $SCLK$ period
  \item Starting from a high (an artbitrary choice), pulse $SCLK$
  \item On each falling edge, send a bit of data until 16 bits have been sent
  \item Pull $SCLK$ back high
  \item Wait one clock period
  \item Pull $\overline{SS}$ back high
\end{enumerate}

The potentiometer has 128 resistance levels that can be chosen from (with 0
being \SI{75}{\ohm} and 127 being \SI{10}{\kilo\ohm}). Suppose we want to set
the resistance to a level $x \in \mathopen[0,127\mathclose]$. Then let $P$ be
the 7-bit binary number representing $x$. To set the resistance to $x$, we write
9 zeroes followed by $P$.

As detailed in the serial protocol above, the Android device sends a byte $B$,
where the MSB determines which potentiometer to change the the 7 LSB determine
the value to send. To determine the address from this we can run

\mint{c}/Byte address = (control & 0x80) ? 0x01: 0x00;/

to set $address$ to the MSB of control. Similarly, we can set the value by
getting the 7 LSB using

\mint{c}/Byte level = control & 0x7F;/


\subsubsection{Program}
To perform all of the above tasks, then, the microcontroller will need to run
the following program:

\begin{itemize}
  \item Setup serial communication (Bluetooth)
  \item Setup potentiometer SPI communicator
  \item Setup ADC communication and initialise data variables
  \item Loop forever:
    \begin{itemize}
      \item Loop 1024 times:
        \begin{itemize}
          \item Take sample from first analog channel
          \item Take sample from second analog channel, if enabled
          \item Take 1-bit sample from each digital channel
        \end{itemize}
      \item Look at most recent serial command, and perform any actions and send
      any data it specifies
      \item Clear most recent serial command
    \end{itemize}
  \item Interrupt on serial byte received:
    \begin{itemize}
      \item Store as most recent serial command
      \item Receive up to 2 more bytes depending on the command
    \end{itemize}
\end{itemize}

There are two main programming languages that can be used for AVR
microcontrollers: Assembly and C. While Assembly was taught in the course, your
author has more extensive previous personal experience using C to program
microcontrollers. Additionally, the higher level of C means less code will be
needed to obtain the same result, and that code wil be more logically
structured. Furthermore, modern C compilers can optimise C code to a smaller
amount of Assembly than any human programmer, meaning the only reason to use
Assembly is for educational purposes.

\subsection{Bluetooth Transceiver}
\label{sec:wireless_transceiver}

As discussed in~\cref{sec:CommOptions}, Bluetooth was chosen to communicate with
the Android device acting as the user interface. In particular, the JY-MCU HC-06
was chosen.

This communicates with the microcontroller via the inbuilt UART interface, as
illustrated in the code in~\cref{lst:uartExample}.

\begin{listing}[H]
  \inputminted{c}{code/USART.c}
  \caption{Example code used to communicate over Bluetooth via the USART
  interface}
  \label{lst:uartExample}
\end{listing}

\subsection{User Interface}
\label{sec:user_interface}

A high-quality enough screen that interfaced directly with the microcontroller
would be quite expensive, so instead an Android device was chosen as the user
interface.

Android was chosen over the alternatives (iOS, etc) primarily because it's the
most popular mobile operating system, allowing the greatest number of people to
use the oscilliscope. Additionally, it allows easy and open development, whereas
competitors such as iOS require costly developer licenses, proprietary software
and specific hardware.

As it's by far the most common and most supported language used for Android,
Java was used to create an Android application that interfaced with the
oscilloscope. Discussing the development of this application is far beyond the
scope (pun not intended) of this project, but the code is fully documented and
available on GitHub at \url{http://github.com/hrickards/bioniscope}. A number of
screenshots are shown in.

\fxwarning{Screenshots of Android App}



\section{Circuit}
Combining all of the subsystems in~\cref{sec:subsystems}, the overall circuit
diagrams shown below ar reached.

\includepdf[landscape=true]{img/pcb/digital.pdf}
\includepdf[landscape=true]{img/pcb/analogue.pdf}


\section{Construction}
Initially, a number of the subsystems were built individually on breadboards.
This allowed the basic circuit details to be checked without requiring an
infeasibly large circuit to be built on a breadboard. 

\subsection{PCB Layout}
Once this prototype verification step was performed, the PCB was laid out on a
breadboard. This process consists of three main steps: inputting the schematic
into the computer, laying out the schematic components onto the board and
routing traces (the PCB equivalent of wires) between the components.

Initially this was attempted using a piece of software called Eagle. A
significant number of electronics projects use Eagle, from small hobbyist
projects right up to industrial products. However, as this author started to lay
components onto the PCB using Eagle, one encountered an error: the free version
of Eagle only allows a maximum PCB size of \SI{100}{\mm}x\SI{80}{\mm}. For
reasons discussed later, the PCB size needed to be \SI{100}{\mm}x\SI{100}{\mm}.
The cheapest paid-version of Eagle is \$169, meaning it was much too expensive
to purchase for the sake of this project. Instead, an alternative was sought.

This author researched and briefly evaluated two alternatives: KiCAD and
DipTrace. KiCAD is a piece of open source software, meaning it's free to
use
\footnote{There are two disctinct definitions of free that should be
considered here: gratis free (without cost to the user, this is somewhat
confusingly also called free as in beer) and libre free (without compromise to
the user's liberties, this is also known as free as in speech and essentially
means that the user has the right to run the software however they want, as
well as the right to modify it, meaning the source code is freely available.
Software that's Free (with a capital F) is also known as open-source software
(there are major differences between the two terms, however for the purposes
of this explanation the reader can consider them identical) is both free as in
gratis and free as in libre, and common examples include LibreOffice (hence
the name) and GNU/Linux (the operating system running everything from the
majority of super computers to televisions to traffic lights). For more on this
subject, see Richard Stallman's book `\textit{Free as in Freedom}', which is
also Free and hence freely available on the internet.},
and DipTrace, a commercial piece of software with a free version available
limited to 2 signal layers\footnote{It would be impractical to have all of the
  traces in a PCB in the same horizontal plane, as they would not be able to
  cross at any point. Instead, a number of planes, or \textit{layers}, are used.
  PCBs are made by pressing together a number of 2-sided PCB `chapters`, meaning
  that common numbers of layers are 2, 4 or 6 (with higher numbers possible but
  more expensive). As it's the cheapest available and offers enough trace
routing, a 2 layer board will be used for this project} and 300
pins\footnote{This project uses somewhere in the region of 250 pins, so this
limit is not a problem}.

Both are very capable pieces of software, and KiCAD would certainly be
favourable for philosophical reasons. Howerver, the majority of the ICs used in
the circuit are relatively uncommon. This means that CAD footprints (files
containing the physical dimensions of the chip) are not readily available, so
they must be manually created for each IC instead. This is a much quicker
process in DipTrace than in KiCAD (and indeed than in Eagle), and for this
reason alone DipTrace was chosen.

There were no major issues in creating the circuit schematic in DipTrace,
although a number of revisions were required for small improvements. Laying out
the PCB and routing the traces was much harder. DipTrace contains tools to
automatically place and route, however the electrical engineering community
strongly recommends against using auto routers. Placing and routing is a task
that's extremely hard for a computer to find an optimal solution
to\footnote{There is a classification of such problems, known as NP. Very
  briefly: a \textit{running time} can be assigned to a given algorithm. For
  example, any algorithm to sort a list of numbers is at most
  $\mathcal{O}\left(n\log{n}\right)$, meaning that as the list of numbers grows
  longer, the running time of the algorithm grows slower than $n\log{n}$, where
  $n$ is the length of the list. We say an algorithm is polynomial-time if the
  running time is polynomial (so e.g., it's $\mathcal{O}\left(n^3\right)$ but
  not $\mathcal{O}\left(2^n\right)$). We then say an NP problem is one where the
  solution to the problem can be checked with a polynomial-time algorithm, but
  there is no polynomial-time algorithm to find that solution. An NP-hard
problem is then a problem that is at least as hard as the hardest NP problems.
Routing just one trace, with no obstacles to avoid, is an NP-hard problem}.
While software can make use of heuristics\footnote{A technique designed to find
a good-enough solution to a problem, when finding the optimal one would take too
long}, it's a commonly held belief that even the best autorouting software pales
when compared to a human with a small amount of experience (it may help to think
of PCB routing as art: while a computer can be programmed to come up with pieces
of art, even a small child can create much better ones).

Because of this, your author set about learning how to place and route PCBs. The
American electronics retailer Sparkfun provide a number of online tutorials and
videos regarding PCB routing which were extremely helpful. Eventually, the PCB
was routed, and while an expert would have done much better it sufficed for the
purposes of this project (particularly as there were no high voltages or
high-speed signals ($\ge\SI{50}{\MHz}$) involved). To finish the board, mounting
holes and silkscreen\footnote{The process is just screen printing, which
originally used silk as the screen, hence the name \textit{silkscreen}} (the
explanatory text and markings on a PCB) were added.

The routed PCB diagram can be seen in a scale version below, and a larger
version in~\cref{fig:largePCBDiagram}. A 3D render the board can be seen
in~\cref{fig:pcb3DRender}. To check component footprints (sizes), an early
version of the PCB was printed onto paper and attached to foam, as seen
in~\cref{fig:pcbFoam}

\includepdf[landscape=true]{img/pcb/pcb.pdf}

\begin{figure}[H]
  \includegraphics[width=\linewidth]{img/pcb/pcbBig.png}
  \caption[PCB (traces)]{Routed PCB}
  \label{fig:largePCBDiagram}
\end{figure}

\begin{figure}[H]
  \includegraphics[width=\linewidth]{img/pcb/pcb3D.png}
  \caption[PCB (3D render)]{3D render of the PCB populated with components (produced by DipTrace)}
  \label{fig:pcb3DRender}
\end{figure}

\begin{figure}[H]
  \includegraphics[width=\linewidth]{img/pcb/pcbFoam.png}
  \caption[PCB (Mockup)]{Photograph of a mockup of the PCB produced using paper and foam,
  allowing the sizes and placements of components to be checked}
  \label{fig:pcbFoam}
\end{figure}

\subsection{PCB Production}
The final step in the process was to get the board manufactured. In an American
or European fab house (the name for the company that prints the boards) this
would be extremely expensive. For example, popular EuroCircuits quoted a price
of over over over \pounds 90 to produce just \textbf{one} board.

Instead, a Chinese proxy to a Chinese fab house was chosen (nearly all low cost
Chinese retailers use the Golden Phoenix fab house, but ordering directly from
them requires a minimum order of 100 square inches, far beyond the size of this
project\footnote{The proxies do something called panelisation: group a number of
small boards onto a larger board, have the large board made at a low cost and
then sell on the small boards for a small amount of profit}). DFRobot was chosen
because it offered more affordable delivery options than the other Chinese
options\footnote{EMS post is universally available for only a couple of dollars,
  but can take upwards of a month to arrive as it's simply air mail. Many
  Chinese retailers will also send goods worth hundreds of pounds through EMS
  post, simply writing `\textit{birthday card}` on the side meaning that while
  the retailer doesn't have to pay any export fees there is a high chance of the
  package spending weeks stuck in customs in the UK. Instead, a courier service
was chosen. Most Chinese PCB retailers only offer UPS and FedEx, which would
have cost around \$30 for this order. DFRobot offered DHL as well, which was
just over half the cost at \$16}. The boards cost \$23.99 for 10 boards, with a
\$16 delivery charge on top. At a cost of \$2.40 per board, ordering from a
Chinese retailer made the boards over 60 times cheaper than orderin from a
European fab house!

As required, the boards were \SI{100}{mm}x\SI{100}{mm} and 2 layers. There were
less choices available (the boards hade to be green, and coated in
HASL\footnote{If the boards were to be sold commercially, then HASL couldn't be
  used as it contains lead so breaks the EU Restriction of Hazardous Substances
  Directive, but for this hobby project using HASL is fine. This does suggest
  another reason why European fab houses are more expensive: hazardous
  substances such as lead can't be used in the board, whereas in China that's
not an issue}) than from a European fab house, but that didn't matter for this
project. Due to the recent Chinese New Year, the boards took slightly longer
than usual to be produced, although still took only 2 working days, something
that EuroCircuits charge over \pounds 150 extra for.

\subsection{Obtaining Parts}

All the ICs had to be specially obtained for the circuit, as they weren't
available in school. Rather than have to purchase them, your author made good
use of the samples programmes run by most semiconductor companies.

Take, for example, the MAX114 ADC. Such a specialist chip would have to be
ordered from a large electronics distributor such as Mouser, who sell it at
\pounds 4.71 per chip. Instead, a number (in this case, 2 were obtained along
with 2 other Maxim ADCs of a similar cost for personal projects) can be freely
obtained from Maxim Integrated, the semiconductor company who make the chip, by
filling out a samples request. Maxim then sent the chips within 3 days (one of
those days being Boxing Day), and they were delivered from the Philliphines in a
further 2 days. All in all, the chips were delivered in the same time it would
have taken had they been ordered from Mouser, but \pounds 25 had been
saved\footnote{Assuming the standard \pounds 10 for delivery from Mouser.}.

One might question why companies such as Maxim provide this free service, and
the answer is twofold. If an engineer used a free sample from Maxim when
prototyping the `\textit{next big thing}', a lot more chips would be required
when producing the real product and Maxim would make a lot more money than it
lost by giving out free samples to lots of engineers. Similar reasoning applies
to students: if the engineers at multi-billion dollar companies all received
free samples from Maxim when they were in college and hence developed brand
loyalty, Maxim will make lots of money.

It should be pointed out that Maxim are not the only company running this
scheme: as of writing, Maxim, Analog Devices, Texas Instruments (or National
Semiconductor), Atmel, Fairchild Semiconductor, Microchip and Linear Technology
are just some of the more well-known companies that offer this service (in fact,
the first 4 provided free samples for this project). Furthermore, if one becomes
a little more adventorous and searches a little further afield, free samples can
be found for everything from enclosures to superbright LEDs. If the reader is
interested in more information, you're advised to
consult~\textcite{LadyAdaSamples}.

\section{Enclosure}

To protect the circuit, an enclosure was needed. There were only a limited
number of places were mounting holes could go on the PCB, so a custom-made
enclosure had to be made rather than using a prebuilt one with standard mounting
hole locations.

The options available to this author were to produce the enclosure using either
a 3D printer or a laser cutter. For easy examiner inspection, the enclosure
needed to be transparent and only coloured plastic filament was available for
the 3D printer, meaning the laser cutter needed to be used.

Rather than using a traditional 3D CAD tool\footnote{Computer Aided Design tool,
such as SolidWorks or AutoDesk Inventor}, OpenSCAD was used. This is an open
source tool that allows 3D objects to be built using \textit{constructive solid
geometry}\footnote{In essence, this allows objects to be built out of primitive
  objects. For example, a basic hammer could be built out of a cuboid and a
cylinder sized and placed appropriately.}. Once the 3D object was created, a
small script was written that took horizontal slices of the object at
appropriate heights, savings DXFs\footnote{An image format, similar to a JPGEG
or PNG, that's commonly used with laser cutters} at each height.

